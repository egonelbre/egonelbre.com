---
date: "2019-01-29T12:00:00+03:00"
title: "Reading Recommendations"
summary: My reading recommendations for software developers.
tags: []
---

I often get asked for recommendations. Here is a list of books and resources I vouch for because I’ve found them invaluable in my journey as a software engineer or have seen them greatly help others.

{{< fig src="/_images/reading-recommendations.jpeg" >}}

---

If you’ve never coded before, then my main recommendation is:

[**Learn Code The Hard Way**](https://learncodethehardway.org/) course by Zed Shaw is one of those great starting places when you have never seen code before. It has plenty of good tips, tricks and exercises to get you started.

_For little ones, playing around with_ [_Scratch_](https://scratch.mit.edu/) _and_ [_Sonic Pi_](https://sonic-pi.net/) _is also great._

---

A few recommendations specifically for Go:

[**Go Training**](https://github.com/ardanlabs/gotraining/) resources by Bill Kennedy is a nice introduction to programming in general and what is a good mental model for programming in Go. He covers a variety of topics and it is all free.

[**Web Development With Go**](https://www.usegolang.com/) course by Jon Calhoun is a comprehensive guide into writing a production ready web application.

[**The Go Programming Language**](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440) book by Alan Donovan and Brian Kernighan.

---

After you have written your first if statements_,_ loops and can manage a 1000 line program.

[**A Philosophy of Software Design**](https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201/ref=sr_1_1?s=books&ie=UTF8&qid=1548418034&sr=1-1&keywords=a+philosophy+of+software) by John Ousterhout is one of those books that helps you get started in moving the right direction for software development mastery. He guides you to find balance in the things you do using clear examples. His list of warning signs helps you notice when things have gone wrong.

[**The Practice of Programming**](https://en.wikipedia.org/wiki/The_Practice_of_Programming) by Brian Kernighan and Rob Pike is an elegant book which covers a variety of topics from comments to testing and performance.

[**The Pragmatic Programmer**](https://en.wikipedia.org/wiki/The_Pragmatic_Programmer) by Andrew Hunt and David Thomas is a step towards looking at the bigger picture of software craftsmanship, not just focusing on the coding.

---

Once you grasp basics you should continue learning by writing a bigger project -- a few packages and around 10,000 lines of code. Otherwise, the following reading might be hard to relate to.

[**On the Criteria To Be Used in Decomposing Systems into Modules**](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf) by David Parnas is a classic that will probably never age. It discusses main concerns when making software modular. It is a great introduction into software architecture.

[**Physics of Software**](http://www.physicsofsoftware.com/) by Carlo Pescio is a hidden gem that hones your intuition on how software evolves and how different pieces interact. Although these concepts may seem very abstract, I use them frequently.

[**Lean Architecture: for Agile Software Development**](http://www.leansoftwarearchitecture.com/) by James Coplien and Gertrud Bjørnvig clearly reminds us to not start from _technology_, but rather from focusing on _creating value_ and on _people_. In the long run it leads to software that adds more value and expresses ideas clearer.

[**Domain Driven Design**](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20) by Eric Evans was interesting to me mainly with regards to how to design and figure out the domain part of the software and communicate it clearly.

[**Working Effectively with Legacy Code**](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) by Michael Feathers has sound advice on how to maintain software. I’ve learned so much from refactoring and making things clearer. Maybe even more than from writing things from scratch. Some day, all successful codebases become legacy, so learning how to manage them is essential.

[**Design Thinking**](https://www.amazon.com/Design-Thinking-Enterprise-Innovation-Sustainability/dp/0998477001) by Dave West and Rebecca Rikner goes into fundamental perspectives, principles, concepts and practices that make design better and more insightful.

[**An Introduction to General Systems Thinking**](https://www.amazon.com/Introduction-General-Systems-Thinking-Anniversary/dp/0932633498) by Gerald Weinberg is an introduction on how to think about complex and chaotic problems where it is impossible to isolate the parts.

---

For performance and algorithms my favourites are:

[**The Algorithm Design Manual**](http://www.algorist.com/) by Steven Skiena is my favorite algorithmics book. I especially recommend reading the War Stories where it makes clearer how people invent algorithms. It’s not a spark of insight, but rather a gradual improvement over days, months and years.

[**Latency Numbers Every Programmer Should Know**](https://gist.github.com/jboner/2841832) is one of those tables that you should have roughly memorized for back-of-the-envelope calculations. In general, the skill of estimating is very useful in making smart decisions about performance.

[**Data Oriented Design**](http://www.dataorienteddesign.com/dodbook/) by Richard Fabian offers a deep dive into using your computer clock cycles efficiently.

[**Algorithm Engineering**](https://www.springer.com/gp/book/9783642148651) goes in depth in all the different parts of designing algorithms (e.g. how to design, derive and test them properly).

---

As programmers we should read code more than we write it. Otherwise it’s easy to end up in our own bubble.

[**The Architecture of Open Source Application**](http://aosabook.org/en/index.html) contains many different case-studies and interesting practical issues that people needed to solve.

[**Game Programming Gems**](http://www.satori.org/game-programming-gems/) series contains many very specific and interesting articles on different problems. It’s a great resource for building up your vocabulary about problems.

Two similar books which I recommend are [**Beautiful Code**](https://www.amazon.com/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047) and [**Programming Pearls**](https://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880).

Of course you should read code, a lot of it. I can highly recommend reading [**SQLite**](https://www.sqlite.org/index.html), [**Plan9**](https://github.com/0intro/plan9) and [**Lua**](https://www.lua.org/source/). Libraries that you use daily are a good place to start.

---

While programming you eventually end up working with other people for one reason or another.

[**ScrumPLOP**](https://sites.google.com/a/scrumplop.org/published-patterns/home) is like a chest of treasures where each pattern is thoroughly thought out and analyses different problems a software team might have. Every pattern has years of experience to back it up. I would recommend to skip the Scrum Guide and go straight to the patterns.

[**Five Dysfunctions of a Team**](https://www.amazon.com/Five-Dysfunctions-Team-Leadership-Fable/dp/0787960756) goes over major things that can go wrong in a team so you can detect it early and counteract.

[**re:Work**](https://rework.withgoogle.com/) by Google shares research insights into how to make work environment and communication better.

---

Even as a programmer you should have a good grasp on how to design usable things and what a human brain is capable of.

[**The Humane Interface**](https://www.amazon.com/Humane-Interface-Directions-Designing-Interactive/dp/0201379376) by Jef Raskin is the introductory book on usability and cognetics. I gained a lot of insight into how to measure and understand usability.

[**The Design of Everyday Things**](https://en.wikipedia.org/wiki/The_Design_of_Everyday_Things) by Don Norman explains human psychology and makes it clear that human interaction is to be expected and failing to take it into account is an error on the designer side.

[**Nielsen/Norman Group**](https://www.nngroup.com/articles/) if you want to stay up to date with the latest news on usability research or you have a very specific topic that interests you. When I have a usability question then that’s the first place I search.

[**The Best Interface is No Interface**](http://www.nointerface.com/book/) reminds that the best solution often is not an app or an interaction, but rather the lack of it.

---

As programmers we spend most of our time building and maintaining solutions, however reflecting on why and what we are building is just as important.

[**Zen and the Art of Motorcycle Maintenance**](https://en.wikipedia.org/wiki/Zen_and_the_Art_of_Motorcycle_Maintenance) by Robert Pirsig is an exploration of what is “quality” and what matters in life.

[**The Nature of Order**](https://en.wikipedia.org/wiki/The_Nature_of_Order) by Christopher Alexander is a formulation of principles that create good environments and life in the world. It’s a description on how to make life better using design.

[**Patterns of Software**](https://www.amazon.com/Patterns-Software-Tales-Community/dp/0195121236) by Richard Gabriel contains many insightful essays on the nature of building software.

---

Somewhat more specialist subject is networking, but nevertheless, you will end up using networks one way or another:

[**Falsehoods programmers believe about networks**](https://blog.erratasec.com/2012/06/falsehoods-programmers-believe-about.html) and [**Fallacies of distributed computing**](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) are very short articles, but will make it clear why networking code is difficult, and therefore make you approach the field with greater reverence.

[**Network Programming with Go**](https://www.apress.com/gp/book/9781484226919) by Jan Newmarch goes over multiple layers of network programming with really nice explanations.

[**Why Do Computers Stop and What Can Be Done About It?**](http://www.hpl.hp.com/techreports/tandem/TR-85.7.pdf) by Jim Gray is a classic and a great introduction to dealing with the inevitable failure of systems.

[**Making reliable distributed systems in the presence of software errors**](http://erlang.org/download/armstrong_thesis_2003.pdf) by Joe Armstrong talks about building reliable systems that can survive in the harshest of conditions.

---

And now the miscellaneous:

[**Structure and Interpretation of Computer Programs**](https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871) by Gerald J. Sussman and Hal Abelson is a classic that teaches how to bend programming to your own needs.

[**NAND2Tetris**](https://www.nand2tetris.org/) course is an introduction to building a virtual computer from the basic elements (almost). It covers machine language, computer architecture, assemblers, high-level languages etc. All in a course form. For an addendum you can watch Ben Eater’s [**Building an 8-bit breadboard computer**](https://www.youtube.com/watch?v=HyznrdDSSGM&list=PLowKtXNTBypGqImE405J2565dvjafglHU).

[**Awesome Falsehoods**](https://github.com/kdeldycke/awesome-falsehood) contains a series of articles by different authors exploring various topics in depth, usually things that people get wrong. Just learning about names is enough to take precautions in every other concern.